/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GhostyPostyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/PublishPreviewModal.ts
var import_obsidian = require("obsidian");
var PublishPreviewModal = class extends import_obsidian.Modal {
  constructor(app, title, markdownContent, initialOptions, onSubmit) {
    super(app);
    this.title = title;
    this.markdownContent = markdownContent;
    this.initialOptions = initialOptions;
    this.onSubmit = onSubmit;
    this.currentOptions = {
      ...initialOptions,
      scheduledTime: initialOptions.scheduledTime || new Date()
    };
    this.previewComponent = new import_obsidian.Component();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Preview & Publish" });
    new import_obsidian.Setting(contentEl).setName("Title").addText((text) => text.setValue(this.title).onChange((value) => {
      this.title = value;
    }));
    let statusDropdown;
    const statusSetting = new import_obsidian.Setting(contentEl).setName("Status").addDropdown((dropdown) => {
      statusDropdown = dropdown;
      return dropdown.addOption("draft", "Draft").addOption("published", "Published").addOption("scheduled", "Scheduled").setValue(this.currentOptions.status).onChange((value) => {
        const newStatus = value;
        this.currentOptions.status = newStatus;
        if (newStatus === "scheduled") {
          scheduleSetting.settingEl.style.display = "flex";
          if (!this.currentOptions.scheduledTime || this.currentOptions.scheduledTime <= new Date()) {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            this.currentOptions.scheduledTime = tomorrow;
            dateInput.value = this.formatDateForInput(tomorrow);
          }
        } else {
          scheduleSetting.settingEl.style.display = "none";
          this.currentOptions.scheduledTime = new Date();
        }
      });
    });
    const scheduleSetting = new import_obsidian.Setting(contentEl).setName("Schedule Post").setDesc('In your local time zone, only used when status is "scheduled"');
    scheduleSetting.settingEl.addClass("schedule-setting");
    const dateInput = scheduleSetting.controlEl.createEl("input", {
      type: "datetime-local",
      value: this.formatDateForInput(this.currentOptions.scheduledTime)
    });
    dateInput.type = "datetime-local";
    dateInput.value = this.formatDateForInput(this.currentOptions.scheduledTime);
    dateInput.className = "publish-preview-datetime-input";
    dateInput.addEventListener("input", (e) => {
      const target = e.target;
      if (target.value) {
        const scheduledDate = new Date(target.value);
        this.currentOptions.scheduledTime = scheduledDate;
      } else {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        this.currentOptions.scheduledTime = tomorrow;
        dateInput.value = this.formatDateForInput(tomorrow);
      }
    });
    if (this.currentOptions.status === "scheduled") {
      scheduleSetting.settingEl.addClass("visible");
    }
    new import_obsidian.Setting(contentEl).setName("Visibility").setDesc("Who can see this post").addDropdown((dropdown) => dropdown.addOption("public", "Everyone").addOption("members", "All Members").addOption("paid", "Paid Members Only").setValue(this.currentOptions.visibility).onChange((value) => {
      this.currentOptions.visibility = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Featured Post").setDesc("Mark this post as featured").addToggle((toggle) => toggle.setValue(this.currentOptions.featured).onChange((value) => {
      this.currentOptions.featured = value;
    }));
    const tagsContainer = contentEl.createDiv();
    new import_obsidian.Setting(tagsContainer).setName("Tags").setDesc("Comma-separated list of tags").addText((text) => text.setValue(this.currentOptions.tags.join(", ")).onChange((value) => {
      this.currentOptions.tags = value.split(",").map((tag) => tag.trim()).filter((tag) => tag.length > 0);
    }));
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container publish-preview-buttons" });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "modal-button"
    });
    cancelButton.addEventListener("click", () => this.close());
    const publishButton = buttonContainer.createEl("button", {
      text: "Publish",
      cls: "modal-button mod-cta"
    });
    publishButton.addEventListener("click", () => {
      this.onSubmit(this.currentOptions);
      this.close();
    });
  }
  formatDateForInput(date) {
    const inputDate = date || new Date();
    const year = inputDate.getFullYear();
    const month = String(inputDate.getMonth() + 1).padStart(2, "0");
    const day = String(inputDate.getDate()).padStart(2, "0");
    const hours = String(inputDate.getHours()).padStart(2, "0");
    const minutes = String(inputDate.getMinutes()).padStart(2, "0");
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.previewComponent.unload();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  ghostUrl: "",
  apiKey: "",
  imagesDirectory: "assets/files",
  openEditorAfterPublish: false,
  recentPostsFile: "Recent Ghost Posts.md",
  enableRecentPosts: false
};
var GhostyPostyPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new GhostyPostySettingTab(this.app, this));
    this.addCommand({
      id: "publish-note-as-draft",
      name: "Publish current note as a draft or post",
      checkCallback: (checking) => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
        if (!activeView) {
          return false;
        }
        if (checking) {
          return !!this.settings.ghostUrl && !!this.settings.apiKey;
        }
        this.publishCurrentNote(activeView);
        return true;
      }
    });
    this.addCommand({
      id: "refresh-recent-posts",
      name: "Refresh recent Ghost posts",
      checkCallback: (checking) => {
        if (checking) {
          return this.settings.enableRecentPosts && !!this.settings.ghostUrl && !!this.settings.apiKey;
        }
        this.updateRecentPosts();
        return true;
      }
    });
    if (this.settings.enableRecentPosts) {
      this.updateRecentPosts();
    }
  }
  parseFrontMatter(content) {
    const frontMatter = {
      status: "draft",
      tags: [],
      featured: false,
      visibility: "public"
    };
    if (!content.startsWith("---")) {
      return { frontMatter, markdownContent: content };
    }
    const secondDivider = content.indexOf("---", 3);
    if (secondDivider === -1) {
      return { frontMatter, markdownContent: content };
    }
    const frontMatterText = content.substring(3, secondDivider).trim();
    const markdownContent = content.substring(secondDivider + 3).trim();
    const lines = frontMatterText.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line)
        continue;
      if (line.includes(":")) {
        const [key, value] = line.split(":", 2).map((s) => s.trim());
        switch (key.toLowerCase()) {
          case "title":
            frontMatter.title = value;
            break;
          case "status":
            frontMatter.status = value === "post" || value === "published" ? "published" : "draft";
            break;
          case "time":
            frontMatter.time = value;
            break;
          case "featured":
            frontMatter.featured = value.toLowerCase() === "true";
            break;
          case "visibility":
            const visibilityValue = value.toLowerCase();
            if (["public", "members", "paid"].includes(visibilityValue)) {
              frontMatter.visibility = visibilityValue;
            }
            break;
          case "tags":
            const tagList = [];
            if (value) {
              value.split(",").forEach((tag) => {
                const trimmedTag = tag.trim();
                if (trimmedTag)
                  tagList.push(trimmedTag);
              });
            } else {
              let j = i + 1;
              while (j < lines.length && lines[j].trim().startsWith("-")) {
                const tag = lines[j].trim().substring(1).trim();
                if (tag)
                  tagList.push(tag);
                j++;
              }
            }
            frontMatter.tags = tagList;
            break;
        }
      }
    }
    return { frontMatter, markdownContent };
  }
  convertObsidianImageLinks(content) {
    return content.replace(/!\[\[(.*?)\]\]/g, "![]($1)");
  }
  formatInlineCode(content) {
    return content.replace(/(?<!`)`([^`]+)`(?!`)/g, (match, code) => {
      return match;
    });
  }
  async processImageLinks(content, view) {
    const imageRegex = /!\[\[(.*?)\]\]/g;
    const imagePaths = [];
    let match;
    while ((match = imageRegex.exec(content)) !== null) {
      imagePaths.push(match[1]);
    }
    if (imagePaths.length === 0) {
      return content;
    }
    const imageMap = /* @__PURE__ */ new Map();
    for (const imagePath of imagePaths) {
      try {
        const ghostUrl = await this.uploadImageToGhost(imagePath, view);
        if (ghostUrl) {
          imageMap.set(imagePath, ghostUrl);
        }
      } catch (error) {
        new import_obsidian2.Notice(`Failed to upload image ${imagePath}: ${error}`);
      }
    }
    let processedContent = content;
    for (const [imagePath, ghostUrl] of imageMap.entries()) {
      const regex = new RegExp(`!\\[\\[${this.escapeRegExp(imagePath)}\\]\\]`, "g");
      processedContent = processedContent.replace(regex, `![](${ghostUrl})`);
    }
    processedContent = this.formatInlineCode(processedContent);
    return processedContent;
  }
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  async uploadImageToGhost(imagePath, view) {
    try {
      const file = this.app.vault.getAbstractFileByPath(this.resolveImagePath(imagePath, view));
      if (!file || !(file instanceof import_obsidian2.TFile)) {
        new import_obsidian2.Notice(`Image not found: ${imagePath}`);
        return null;
      }
      const fileData = await this.app.vault.readBinary(file);
      const uploadUrl = await this.uploadFileToGhost(file.name, fileData);
      if (uploadUrl) {
        return uploadUrl;
      } else {
        new import_obsidian2.Notice("Failed to upload image");
        return null;
      }
    } catch (error) {
      new import_obsidian2.Notice(`Error uploading image ${imagePath}: ${error}`);
      return null;
    }
  }
  resolveImagePath(imagePath, view) {
    var _a, _b;
    if (imagePath.startsWith("/")) {
      return imagePath;
    }
    const currentNotePath = ((_b = (_a = view.file) == null ? void 0 : _a.parent) == null ? void 0 : _b.path) || "";
    const relativeToNote = `${currentNotePath}/${imagePath}`;
    if (this.app.vault.getAbstractFileByPath(relativeToNote)) {
      return relativeToNote;
    }
    return `${this.settings.imagesDirectory}/${imagePath}`;
  }
  async uploadFileToGhost(fileName, fileData) {
    var _a, _b, _c;
    try {
      const { ghostUrl, apiKey } = this.settings;
      if (!ghostUrl || !apiKey) {
        new import_obsidian2.Notice("Ghost URL and API Key are required");
        return null;
      }
      const baseUrl = ghostUrl.trim().replace(/\/$/, "");
      const [id, secret] = apiKey.split(":");
      if (!id || !secret) {
        new import_obsidian2.Notice("Invalid API key format");
        return null;
      }
      const apiUrl = `${baseUrl}/ghost/api/admin/images/upload/`;
      const boundary = "----WebKitFormBoundary" + Math.random().toString(16).substring(2);
      const fileHeader = `--${boundary}\r
Content-Disposition: form-data; name="file"; filename="${fileName}"\r
Content-Type: ${this.getMimeType(fileName)}\r
\r
`;
      const fileFooter = `\r
--${boundary}--\r
`;
      const headerBuffer = new TextEncoder().encode(fileHeader);
      const footerBuffer = new TextEncoder().encode(fileFooter);
      const combinedBuffer = new Uint8Array(headerBuffer.byteLength + fileData.byteLength + footerBuffer.byteLength);
      combinedBuffer.set(new Uint8Array(headerBuffer), 0);
      combinedBuffer.set(new Uint8Array(fileData), headerBuffer.byteLength);
      combinedBuffer.set(new Uint8Array(footerBuffer), headerBuffer.byteLength + fileData.byteLength);
      const authToken = this.generateGhostAdminToken(id, secret);
      try {
        const response = await (0, import_obsidian2.requestUrl)({
          url: apiUrl,
          method: "POST",
          headers: {
            "Content-Type": `multipart/form-data; boundary=${boundary}`,
            "Authorization": authToken
          },
          body: combinedBuffer,
          throw: true
        });
        if (response.status >= 200 && response.status < 300) {
          return ((_c = (_b = (_a = response.json) == null ? void 0 : _a.images) == null ? void 0 : _b[0]) == null ? void 0 : _c.url) || null;
        } else {
          return null;
        }
      } catch (error) {
        return await this.uploadFileWithNode(apiUrl, id, secret, fileName, fileData);
      }
    } catch (error) {
      new import_obsidian2.Notice(`Error uploading image ${fileName}: ${error}`);
      return null;
    }
  }
  async uploadFileWithNode(url, id, secret, fileName, fileData) {
    return new Promise((resolve) => {
      try {
        const nodeRequire = window.require;
        if (!nodeRequire) {
          resolve(null);
          return;
        }
        const https = nodeRequire("https");
        const crypto = nodeRequire("crypto");
        const urlObj = new URL(url);
        const boundary = "----NodeJSFormBoundary" + Math.random().toString(16).substring(2);
        const now = Math.floor(Date.now() / 1e3);
        const fiveMinutesFromNow = now + 5 * 60;
        const header = {
          alg: "HS256",
          typ: "JWT",
          kid: id
        };
        const payload = {
          iat: now,
          exp: fiveMinutesFromNow,
          aud: "/v5/admin/"
        };
        const encodeBase64 = (obj) => {
          const str = JSON.stringify(obj);
          return crypto.createHash("sha256").update(str).digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
        };
        const headerBase64 = Buffer.from(JSON.stringify(header)).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
        const payloadBase64 = Buffer.from(JSON.stringify(payload)).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
        const signatureInput = `${headerBase64}.${payloadBase64}`;
        const signature = crypto.createHmac("sha256", Buffer.from(secret, "hex")).update(signatureInput).digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
        const token = `${headerBase64}.${payloadBase64}.${signature}`;
        const fileHeader = `--${boundary}\r
Content-Disposition: form-data; name="file"; filename="${fileName}"\r
Content-Type: ${this.getMimeType(fileName)}\r
\r
`;
        const fileFooter = `\r
--${boundary}--\r
`;
        const headerBuffer = Buffer.from(fileHeader);
        const footerBuffer = Buffer.from(fileFooter);
        const fileBuffer = Buffer.from(fileData);
        const dataBuffer = Buffer.concat([
          headerBuffer,
          fileBuffer,
          footerBuffer
        ]);
        const options = {
          hostname: urlObj.hostname,
          path: urlObj.pathname + urlObj.search,
          method: "POST",
          headers: {
            "Content-Type": `multipart/form-data; boundary=${boundary}`,
            "Content-Length": dataBuffer.length,
            "Authorization": `Ghost ${token}`
          }
        };
        const req = https.request(options, (res) => {
          let data = "";
          res.on("data", (chunk) => {
            data += chunk;
          });
          res.on("end", () => {
            var _a, _b;
            if (res.statusCode >= 200 && res.statusCode < 300) {
              try {
                const jsonData = JSON.parse(data);
                resolve(((_b = (_a = jsonData == null ? void 0 : jsonData.images) == null ? void 0 : _a[0]) == null ? void 0 : _b.url) || null);
              } catch (e) {
                resolve(null);
              }
            } else {
              resolve(null);
            }
          });
        });
        req.on("error", (error) => {
          resolve(null);
        });
        req.write(dataBuffer);
        req.end();
      } catch (error) {
        resolve(null);
      }
    });
  }
  getMimeType(fileName) {
    var _a;
    const extension = (_a = fileName.split(".").pop()) == null ? void 0 : _a.toLowerCase();
    const mimeTypes = {
      "jpg": "image/jpeg",
      "jpeg": "image/jpeg",
      "png": "image/png",
      "gif": "image/gif",
      "webp": "image/webp",
      "svg": "image/svg+xml",
      "tiff": "image/tiff",
      "tif": "image/tiff",
      "bmp": "image/bmp"
    };
    return mimeTypes[extension || ""] || "application/octet-stream";
  }
  async publishCurrentNote(view) {
    var _a;
    try {
      const editor = view.editor;
      const content = editor.getValue();
      const fileName = ((_a = view.file) == null ? void 0 : _a.basename) || "Untitled Note";
      const { frontMatter, markdownContent } = this.parseFrontMatter(content);
      const processedContent = await this.processImageLinks(markdownContent, view);
      const title = frontMatter.title || fileName;
      const initialOptions = {
        status: frontMatter.status || "draft",
        tags: frontMatter.tags || [],
        featured: frontMatter.featured || false,
        visibility: frontMatter.visibility || "public",
        scheduledTime: frontMatter.time ? new Date(frontMatter.time) : new Date()
      };
      new PublishPreviewModal(this.app, title, processedContent, initialOptions, async (options) => {
        const result = await this.publishToGhost(title, processedContent, {
          ...frontMatter,
          status: options.status,
          tags: options.tags,
          featured: options.featured,
          visibility: options.visibility,
          time: options.scheduledTime ? options.scheduledTime.toISOString() : void 0
        });
        if (result.success) {
          new import_obsidian2.Notice(`Successfully published "${title}" as ${options.status}`);
        } else {
          new import_obsidian2.Notice(`Failed to publish: ${result.error}`);
        }
      }).open();
    } catch (error) {
      new import_obsidian2.Notice(`Error publishing note: ${error}`);
    }
  }
  generateGhostAdminToken(id, secret) {
    try {
      const crypto = window.require ? window.require("crypto") : null;
      if (!crypto) {
        return `Ghost ${id}:${secret}`;
      }
      const now = Math.floor(Date.now() / 1e3);
      const fiveMinutesFromNow = now + 5 * 60;
      const header = {
        alg: "HS256",
        typ: "JWT",
        kid: id
      };
      const payload = {
        iat: now,
        exp: fiveMinutesFromNow,
        aud: "/v5/admin/"
      };
      const encodeBase64 = (obj) => {
        const str = JSON.stringify(obj);
        return crypto.createHash("sha256").update(str).digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
      };
      const headerBase64 = Buffer.from(JSON.stringify(header)).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
      const payloadBase64 = Buffer.from(JSON.stringify(payload)).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
      const signatureInput = `${headerBase64}.${payloadBase64}`;
      const signature = crypto.createHmac("sha256", Buffer.from(secret, "hex")).update(signatureInput).digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
      const token = `${headerBase64}.${payloadBase64}.${signature}`;
      return `Ghost ${token}`;
    } catch (error) {
      return `Ghost ${id}:${secret}`;
    }
  }
  parseMarkdownToMobiledoc(content) {
    const createTextNode = (text, format = 0) => ({
      type: "text",
      text,
      detail: 0,
      format,
      mode: "normal",
      style: "",
      version: 1
    });
    const createParagraphNode = (children) => ({
      type: "paragraph",
      children,
      direction: "ltr",
      format: 0,
      indent: 0,
      version: 1
    });
    const createListNode = (listItems, listType) => ({
      type: "list",
      listType,
      start: 1,
      children: listItems,
      direction: "ltr",
      format: 0,
      indent: 0,
      version: 1
    });
    const createListItemNode = (children) => ({
      type: "listitem",
      children,
      direction: "ltr",
      format: 0,
      indent: 0,
      value: 1,
      version: 1
    });
    const processTextWithMarkup = (text) => {
      const nodes = [];
      let currentIndex = 0;
      const markupRegex = /(?:```[\s\S]*?```)|(?:`[^`]+`)|(?:\[([^\]]+)\]\(([^)]+)\))|(?:\*\*[^*]+\*\*)|(?:__[^_]+__)|(?:\*[^*]+\*)/g;
      let match;
      while ((match = markupRegex.exec(text)) !== null) {
        if (match.index > currentIndex) {
          nodes.push(createTextNode(text.slice(currentIndex, match.index)));
        }
        const matchedText = match[0];
        if (matchedText.startsWith("```")) {
          nodes.push(createTextNode(matchedText));
        } else if (matchedText.startsWith("`")) {
          const code = matchedText.slice(1, -1);
          nodes.push(createTextNode(code, 16));
        } else if (matchedText.startsWith("[")) {
          const linkMatch = /\[([^\]]+)\]\(([^)]+)\)/.exec(matchedText);
          if (linkMatch) {
            nodes.push({
              type: "link",
              url: linkMatch[2],
              children: [createTextNode(linkMatch[1])],
              direction: "ltr",
              format: 0,
              indent: 0,
              version: 1
            });
          }
        } else if (matchedText.startsWith("**") || matchedText.startsWith("__")) {
          const boldText = matchedText.slice(2, -2);
          nodes.push(createTextNode(boldText, 1));
        } else if (matchedText.startsWith("*")) {
          const italicText = matchedText.slice(1, -1);
          nodes.push(createTextNode(italicText, 2));
        }
        currentIndex = match.index + matchedText.length;
      }
      if (currentIndex < text.length) {
        nodes.push(createTextNode(text.slice(currentIndex)));
      }
      return nodes;
    };
    const rootChildren = [];
    let currentListItems = null;
    let currentListType = null;
    const paragraphBlocks = content.split("\n\n").filter((p) => p.trim());
    paragraphBlocks.forEach((block) => {
      const lines = block.split("\n").filter((line) => line.trim());
      lines.forEach((line) => {
        const trimmedLine = line.trim();
        const bulletListMatch = trimmedLine.match(/^[-*]\s+(.+)$/);
        const numberListMatch = trimmedLine.match(/^(\d+)\.\s+(.+)$/);
        if (bulletListMatch || numberListMatch) {
          const listText = bulletListMatch ? bulletListMatch[1] : numberListMatch[2];
          const listType = bulletListMatch ? "bullet" : "number";
          if (!currentListItems || currentListType !== listType) {
            if (currentListItems) {
              rootChildren.push(createListNode(currentListItems, currentListType));
            }
            currentListItems = [];
            currentListType = listType;
          }
          currentListItems.push(createListItemNode([
            createParagraphNode(processTextWithMarkup(listText))
          ]));
          return;
        }
        if (currentListItems) {
          rootChildren.push(createListNode(currentListItems, currentListType));
          currentListItems = null;
          currentListType = null;
        }
        if (trimmedLine === "---") {
          rootChildren.push({
            type: "horizontalrule",
            version: 1
          });
          return;
        }
        const headingMatch = trimmedLine.match(/^(#{1,6})\s+(.+)$/m);
        if (headingMatch) {
          const level = headingMatch[1].length;
          const text = headingMatch[2].trim();
          rootChildren.push({
            type: "heading",
            tag: `h${level}`,
            children: processTextWithMarkup(text),
            direction: "ltr",
            format: 0,
            indent: 0,
            version: 1
          });
          return;
        }
        if (trimmedLine.startsWith(">")) {
          const quoteText = trimmedLine.substring(1).trim();
          rootChildren.push({
            type: "quote",
            children: [createParagraphNode(processTextWithMarkup(quoteText))],
            direction: "ltr",
            format: 0,
            indent: 0,
            version: 1
          });
          return;
        }
        const imageMatch = trimmedLine.match(/^!\[(.*?)\]\((.*?)\)$/);
        if (imageMatch) {
          const [_, alt, src] = imageMatch;
          rootChildren.push({
            type: "image",
            src,
            altText: alt,
            width: void 0,
            height: void 0,
            maxWidth: "100%",
            showCaption: false,
            caption: void 0,
            direction: "ltr",
            format: 0,
            indent: 0,
            version: 1
          });
          return;
        }
        rootChildren.push(createParagraphNode(processTextWithMarkup(trimmedLine)));
      });
    });
    if (currentListItems) {
      rootChildren.push(createListNode(currentListItems, currentListType));
    }
    const root = {
      type: "root",
      children: rootChildren,
      direction: "ltr",
      format: 0,
      indent: 0,
      version: 1
    };
    return JSON.stringify({ root });
  }
  async publishToGhost(title, markdownContent, frontMatter) {
    var _a, _b, _c, _d;
    try {
      const { ghostUrl, apiKey } = this.settings;
      if (!ghostUrl || !apiKey) {
        return {
          success: false,
          error: "Ghost URL and API Key are required"
        };
      }
      const baseUrl = ghostUrl.trim().replace(/\/$/, "");
      const [id, secret] = apiKey.split(":");
      if (!id || !secret) {
        return {
          success: false,
          error: "Invalid API key format"
        };
      }
      const cleanMarkdown = markdownContent.trim();
      console.log("Original Markdown content:", cleanMarkdown);
      const lines = cleanMarkdown.split("\n");
      let featuredImage;
      let contentWithoutFirstImage = cleanMarkdown;
      if (lines.length > 0) {
        const firstLine = lines[0].trim();
        const imageMatch = firstLine.match(/^!\[.*?\]\((.*?)\)$/);
        if (imageMatch) {
          featuredImage = imageMatch[1];
          contentWithoutFirstImage = lines.slice(1).join("\n").trim();
        }
      }
      const lexical = this.parseMarkdownToMobiledoc(contentWithoutFirstImage);
      console.log("Lexical format:", lexical);
      const postData = {
        posts: [{
          title,
          lexical,
          status: frontMatter.status || "draft",
          featured: frontMatter.featured || false,
          visibility: frontMatter.visibility || "public",
          published_at: null
        }]
      };
      console.log("Final post data:", JSON.stringify(postData, null, 2));
      if (featuredImage) {
        postData.posts[0].feature_image = featuredImage;
      }
      if (frontMatter.tags && frontMatter.tags.length > 0) {
        postData.posts[0].tags = frontMatter.tags.map((tag) => ({ name: tag }));
      }
      if (frontMatter.status === "scheduled" && frontMatter.time) {
        postData.posts[0].published_at = frontMatter.time;
      } else if (frontMatter.status === "published") {
        postData.posts[0].published_at = new Date().toISOString();
      }
      try {
        const authToken = this.generateGhostAdminToken(id, secret);
        const response = await (0, import_obsidian2.requestUrl)({
          url: `${baseUrl}/ghost/api/admin/posts/`,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": authToken
          },
          body: JSON.stringify(postData),
          throw: false
        });
        if (response.status >= 200 && response.status < 300) {
          const jsonData = response.json;
          let postUrl = "";
          try {
            postUrl = ((_b = (_a = jsonData == null ? void 0 : jsonData.posts) == null ? void 0 : _a[0]) == null ? void 0 : _b.url) || "";
          } catch (e) {
            console.log("Could not extract post URL from response");
          }
          if (this.settings.openEditorAfterPublish && ((_d = (_c = jsonData == null ? void 0 : jsonData.posts) == null ? void 0 : _c[0]) == null ? void 0 : _d.id)) {
            const editorUrl = `${this.settings.ghostUrl}/ghost/#/editor/post/${jsonData.posts[0].id}`;
            window.open(editorUrl, "_blank");
          }
          return {
            success: true,
            postUrl
          };
        } else {
          const errorResponse = response.text;
          console.error("API Error when publishing:", response.status);
          console.error("Error response body:", errorResponse);
          if (errorResponse.includes("INVALID_JWT") || errorResponse.includes("Invalid token")) {
            console.log("Token error detected, trying Node.js method with proper JWT...");
            return await this.publishWithNode(baseUrl, id, secret, postData);
          }
          return {
            success: false,
            error: `API Error (${response.status}): ${errorResponse}`
          };
        }
      } catch (error) {
        console.error("Obsidian request failed when publishing, trying Node.js:", error);
        return await this.publishWithNode(baseUrl, id, secret, postData);
      }
    } catch (error) {
      console.error("Publish error:", error);
      return {
        success: false,
        error: `Error during publishing: ${error}`
      };
    }
  }
  async publishWithNode(url, id, secret, postData) {
    return new Promise((resolve) => {
      try {
        const nodeRequire = window.require;
        if (!nodeRequire) {
          resolve({
            success: false,
            error: "Could not access Node.js modules for publishing"
          });
          return;
        }
        const https = nodeRequire("https");
        const crypto = nodeRequire("crypto");
        const urlObj = new URL(url);
        const now = Math.floor(Date.now() / 1e3);
        const fiveMinutesFromNow = now + 5 * 60;
        const header = {
          alg: "HS256",
          typ: "JWT",
          kid: id
        };
        const payload = {
          iat: now,
          exp: fiveMinutesFromNow,
          aud: "/v5/admin/"
        };
        const headerBase64 = Buffer.from(JSON.stringify(header)).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
        const payloadBase64 = Buffer.from(JSON.stringify(payload)).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
        const signatureInput = `${headerBase64}.${payloadBase64}`;
        const signature = crypto.createHmac("sha256", Buffer.from(secret, "hex")).update(signatureInput).digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
        const token = `${headerBase64}.${payloadBase64}.${signature}`;
        const authToken = `Ghost ${token}`;
        const postContent = JSON.stringify(postData);
        const options = {
          hostname: urlObj.hostname,
          path: urlObj.pathname + urlObj.search,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Content-Length": postContent.length,
            "Authorization": authToken
          }
        };
        const req = https.request(options, (res) => {
          let data = "";
          res.on("data", (chunk) => {
            data += chunk;
          });
          res.on("end", () => {
            var _a, _b, _c, _d;
            if (res.statusCode >= 200 && res.statusCode < 300) {
              try {
                const jsonData = JSON.parse(data);
                let postUrl = "";
                try {
                  postUrl = ((_b = (_a = jsonData == null ? void 0 : jsonData.posts) == null ? void 0 : _a[0]) == null ? void 0 : _b.url) || "";
                } catch (e) {
                  console.log("Could not extract post URL from response");
                }
                if (this.settings.openEditorAfterPublish && ((_d = (_c = jsonData == null ? void 0 : jsonData.posts) == null ? void 0 : _c[0]) == null ? void 0 : _d.id)) {
                  const editorUrl = `${this.settings.ghostUrl}/ghost/#/editor/post/${jsonData.posts[0].id}`;
                  window.open(editorUrl, "_blank");
                }
                resolve({
                  success: true,
                  postUrl
                });
              } catch (e) {
                console.error("Error parsing JSON from publish response:", e);
                resolve({
                  success: true,
                  error: `Could not parse response data: ${e}`
                });
              }
            } else {
              console.error("API Error from Node.js publish:", res.statusCode);
              console.error("Error response body:", data);
              resolve({
                success: false,
                error: `API Error (${res.statusCode}): ${data}`
              });
            }
          });
        });
        req.on("error", (error) => {
          console.error("Node.js publish error:", error);
          resolve({
            success: false,
            error: `Network error during publishing: ${error.message}`
          });
        });
        req.write(postContent);
        req.end();
      } catch (error) {
        console.error("Error in Node.js publishing:", error);
        resolve({
          success: false,
          error: `Error during publishing: ${error}`
        });
      }
    });
  }
  onunload() {
    console.log("Unloaded Ghosty Posty plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async fetchRecentPosts() {
    try {
      const { ghostUrl, apiKey } = this.settings;
      if (!ghostUrl || !apiKey) {
        throw new Error("Ghost URL and API Key are required");
      }
      const baseUrl = ghostUrl.trim().replace(/\/$/, "");
      const [id, secret] = apiKey.split(":");
      if (!id || !secret) {
        throw new Error("Invalid API key format");
      }
      const authToken = this.generateGhostAdminToken(id, secret);
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${baseUrl}/ghost/api/admin/posts/?limit=20&order=published_at%20desc&formats=mobiledoc,html,plaintext&include=tags`,
        method: "GET",
        headers: {
          "Authorization": authToken
        }
      });
      if (response.status !== 200) {
        throw new Error(`API Error: ${response.status}`);
      }
      const posts = response.json.posts;
      return posts.map((post) => ({
        title: post.title,
        url: post.url,
        published_at: post.published_at,
        tags: (post.tags || []).map((tag) => tag.name)
      }));
    } catch (error) {
      console.error("Error fetching recent posts:", error);
      throw error;
    }
  }
  async updateRecentPosts() {
    try {
      if (!this.settings.enableRecentPosts) {
        return;
      }
      const posts = await this.fetchRecentPosts();
      const formatDate = (dateStr) => {
        const date = new Date(dateStr);
        return date.toLocaleDateString("en-US", {
          year: "numeric",
          month: "long",
          day: "numeric"
        });
      };
      const content = [
        "# Recent Ghost Posts",
        "",
        "Last updated: " + new Date().toLocaleDateString("en-US", {
          year: "numeric",
          month: "long",
          day: "numeric"
        }),
        "",
        "| Title | Date | Tags |",
        "|-------|------|------|",
        ...posts.map((post) => {
          const date = formatDate(post.published_at);
          const title = `[${post.title}](${post.url})`;
          const tags = post.tags.length > 0 ? post.tags.join(", ") : "-";
          const escapedTitle = title.replace(/\|/g, "\\|");
          const escapedTags = tags.replace(/\|/g, "\\|");
          return `| ${escapedTitle} | ${date} | ${escapedTags} |`;
        })
      ].join("\n");
      const filePath = this.settings.recentPostsFile;
      let file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file) {
        file = await this.app.vault.create(filePath, content);
        new import_obsidian2.Notice(`Created recent posts file: ${filePath}`);
      } else if (file instanceof import_obsidian2.TFile) {
        await this.app.vault.modify(file, content);
        new import_obsidian2.Notice("Updated recent posts");
      }
    } catch (error) {
      new import_obsidian2.Notice(`Error updating recent posts: ${error}`);
    }
  }
};
var GhostyPostySettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Ghosty Posty Settings" });
    new import_obsidian2.Setting(containerEl).setName("Ghost Blog URL").setDesc("URL of your Ghost blog (ex: https://yourblog.com)").addText((text) => text.setPlaceholder("https://yourblog.com").setValue(this.plugin.settings.ghostUrl).onChange(async (value) => {
      this.plugin.settings.ghostUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Admin API Key").setDesc("Your Ghost Admin API key").addText((text) => text.setPlaceholder("00000000000000000000:00000000000000000000000000000000000000000000").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Images Directory").setDesc("Default directory in your vault where images are stored (e.g., assets/files)").addText((text) => text.setPlaceholder("assets/files").setValue(this.plugin.settings.imagesDirectory).onChange(async (value) => {
      this.plugin.settings.imagesDirectory = value.replace(/^\/+|\/+$/g, "");
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Open Editor After Publish").setDesc("Whether to open the editor after publishing a post").addToggle((toggle) => toggle.setValue(this.plugin.settings.openEditorAfterPublish).onChange(async (value) => {
      this.plugin.settings.openEditorAfterPublish = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Recent Posts File").setDesc("The file name for the recent posts file").addText((text) => text.setPlaceholder("Recent Ghost Posts.md").setValue(this.plugin.settings.recentPostsFile).onChange(async (value) => {
      this.plugin.settings.recentPostsFile = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Enable Recent Posts").setDesc("Whether to enable the recent posts feature").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableRecentPosts).onChange(async (value) => {
      this.plugin.settings.enableRecentPosts = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Test Connection").setDesc("Verify your Ghost credentials").addButton((button) => button.setButtonText("Test Connection").setCta().onClick(async () => {
      button.setDisabled(true);
      button.setButtonText("Testing...");
      try {
        const result = await this.testGhostConnection();
        if (result.success) {
          new import_obsidian2.Notice("Connection successful!");
        } else {
          new import_obsidian2.Notice(`Connection failed: ${result.error}`);
        }
      } finally {
        button.setDisabled(false);
        button.setButtonText("Test Connection");
      }
    }));
  }
  async testGhostConnection() {
    try {
      const { ghostUrl, apiKey } = this.plugin.settings;
      if (!ghostUrl || !apiKey) {
        return {
          success: false,
          error: "Please enter both Ghost URL and API Key"
        };
      }
      const baseUrl = ghostUrl.trim().replace(/\/$/, "");
      try {
        new URL(baseUrl);
      } catch (e) {
        return {
          success: false,
          error: "Invalid URL format"
        };
      }
      const [id, secret] = apiKey.split(":");
      if (!id || !secret) {
        return {
          success: false,
          error: "Invalid API key format. Should be ID:SECRET"
        };
      }
      const possibleEndpoints = [
        `/ghost/api/admin/posts/`,
        `/ghost/api/admin/settings/`,
        `/ghost/api/admin/users/me/`,
        `/ghost/api/admin/site/`
      ];
      for (const endpoint of possibleEndpoints) {
        try {
          const testUrl = `${baseUrl}${endpoint}`;
          const response = await (0, import_obsidian2.requestUrl)({
            url: testUrl,
            method: "GET",
            headers: {
              "Authorization": `Ghost ${id}:${secret}`
            },
            throw: false
          });
          if (response.status >= 200 && response.status < 300) {
            return { success: true };
          }
        } catch (e) {
          continue;
        }
      }
      return {
        success: false,
        error: "Connection failed. Please check your Ghost URL and API Key"
      };
    } catch (error) {
      return {
        success: false,
        error: `Error during connection test: ${error}`
      };
    }
  }
};
